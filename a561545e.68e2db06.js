/*! For license information please see a561545e.68e2db06.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{184:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return p})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return b})),n.d(t,"default",(function(){return u}));var r=n(1),a=n(9),i=(n(0),n(220)),o=n(229),l=n(228),p={id:"sprites",title:"Sprites"},c={id:"sprites",title:"Sprites",description:"Replay is all about Sprites. Sprites are similar to Components in React.",source:"@site/docs/sprites.md",permalink:"/docs/sprites",editUrl:"https://github.com/edbentley/replay/edit/master/website/docs/sprites.md",sidebar:"someSidebar",previous:{title:"Replay Starter",permalink:"/docs/starter"},next:{title:"Textures",permalink:"/docs/textures"}},b=[{value:"Custom Sprite",id:"custom-sprite",children:[]},{value:"Stateful Sprite",id:"stateful-sprite",children:[]},{value:"Anchor Point",id:"anchor-point",children:[]},{value:"Common Props",id:"common-props",children:[]},{value:"Sprite Methods",id:"sprite-methods",children:[{value:"Common Parameters",id:"common-parameters",children:[]},{value:"<code>init</code>",id:"init",children:[]},{value:"<code>loop</code>",id:"loop",children:[]},{value:"<code>render</code>",id:"render",children:[]},{value:"<code>renderP</code>",id:"renderp",children:[]},{value:"<code>renderXL</code>",id:"renderxl",children:[]},{value:"<code>renderPXL</code>",id:"renderpxl",children:[]}]}],s={rightToc:b};function u(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Replay is all about Sprites. Sprites are similar to Components in React."),Object(i.b)("h2",{id:"custom-sprite"},"Custom Sprite"),Object(i.b)("p",null,"You can create a ",Object(i.b)("em",{parentName:"p"},"custom")," Sprite by passing an object into the ",Object(i.b)("inlineCode",{parentName:"p"},"makeSprite")," function:"),Object(i.b)(o.a,{defaultValue:"js",groupId:"code",values:[{label:"JavaScript",value:"js"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"js",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'import { t, makeSprite } from "@replay/core";\n\nexport const Player = makeSprite({\n  render({ props }) {\n    return [\n      t.circle({\n        radius: 10,\n        color: props.color,\n      }),\n    ];\n  },\n});\n'))),Object(i.b)(l.a,{value:"ts",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),'import { t, makeSprite } from "@replay/core";\n\ntype Props = {\n  color: string;\n};\nexport const Player = makeSprite<Props>({\n  render({ props }) {\n    return [\n      t.circle({\n        radius: 10,\n        color: props.color,\n      }),\n    ];\n  },\n});\n')))),Object(i.b)("p",null,"The Sprite object passed into ",Object(i.b)("inlineCode",{parentName:"p"},"makeSprite")," must have a method called ",Object(i.b)("inlineCode",{parentName:"p"},"render"),". The return value of ",Object(i.b)("inlineCode",{parentName:"p"},"render")," - an array of Sprites - is what Replay will draw onto the screen. Here we're drawing a circle with the colour set in its ",Object(i.b)("inlineCode",{parentName:"p"},"props"),"."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"props")," are values other Sprites can pass into the Sprite - just like arguments of a function. They're ",Object(i.b)("strong",{parentName:"p"},"read-only")," and should not be mutated."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"t")," is used to generate a ",Object(i.b)("em",{parentName:"p"},"Texture"),", which is a type of Sprite. The ",Object(i.b)("inlineCode",{parentName:"p"},"t.circle")," Texture accepts two ",Object(i.b)("inlineCode",{parentName:"p"},"props"),": ",Object(i.b)("inlineCode",{parentName:"p"},"radius")," and ",Object(i.b)("inlineCode",{parentName:"p"},"color"),". We'll cover them in more detail in ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/textures"}),"Textures")," next."),Object(i.b)("p",null,"Although not required, it's convention to capitalise custom Sprite names (",Object(i.b)("inlineCode",{parentName:"p"},"Player"),", not ",Object(i.b)("inlineCode",{parentName:"p"},"player"),")."),Object(i.b)("h2",{id:"stateful-sprite"},"Stateful Sprite"),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"Player")," Sprite is a pure function of ",Object(i.b)("inlineCode",{parentName:"p"},"props"),". But we can create an interactive Sprite by adding ",Object(i.b)("inlineCode",{parentName:"p"},"state"),":"),Object(i.b)(o.a,{defaultValue:"js",groupId:"code",values:[{label:"JavaScript",value:"js"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"js",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'import { makeSprite } from "@replay/core";\nimport { Player } from "./player";\n\nexport const Level = makeSprite({\n  init() {\n    return { playerX: 0 };\n  },\n\n  loop({ state }) {\n    return {\n      playerX: state.playerX + 1,\n    };\n  },\n\n  render({ state }) {\n    return [\n      Player({\n        id: "player",\n        x: state.playerX,\n        rotation: 10,\n        color: "red",\n      }),\n    ];\n  },\n});\n\n'))),Object(i.b)(l.a,{value:"ts",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),'import { makeSprite } from "@replay/core";\nimport { WebInputs } from "@replay/web";\nimport { iOSInputs } from "@replay/swift";\nimport { Player } from "./player";\n\ntype Props = {};\ntype State = {\n  playerX: number;\n};\n\nexport const Level = makeSprite<Props, State, WebInputs | iOSInputs>({\n  init() {\n    return { playerX: 0 };\n  },\n\n  loop({ state }) {\n    return {\n      playerX: state.playerX + 1,\n    };\n  },\n\n  render({ state }) {\n    return [\n      Player({\n        id: "player",\n        x: state.playerX,\n        rotation: 10,\n        color: "red",\n      }),\n    ];\n  },\n});\n')))),Object(i.b)("p",null,"This ",Object(i.b)("inlineCode",{parentName:"p"},"Level")," Sprite has an ",Object(i.b)("inlineCode",{parentName:"p"},"init")," method which returns the initial state - a value ",Object(i.b)("inlineCode",{parentName:"p"},"playerX")," for the player's ",Object(i.b)("inlineCode",{parentName:"p"},"x")," position."),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"loop")," method takes the current ",Object(i.b)("inlineCode",{parentName:"p"},"state")," and returns a new value for ",Object(i.b)("inlineCode",{parentName:"p"},"state"),". This is where we can write our game logic for interactive things (in this case we're increasing the player's ",Object(i.b)("inlineCode",{parentName:"p"},"x")," position). ",Object(i.b)("inlineCode",{parentName:"p"},"loop")," is called by Replay 60 times a second (we'll cover this more in ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/game-loop"}),"Game Loop"),")."),Object(i.b)("p",null,"Just like ",Object(i.b)("inlineCode",{parentName:"p"},"props"),", ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"state")," is also read-only"),". You should always return a new value of ",Object(i.b)("inlineCode",{parentName:"p"},"state")," and not mutate it, ensuring the ",Object(i.b)("inlineCode",{parentName:"p"},"loop")," method remains pure."),Object(i.b)("p",null,"Lastly our ",Object(i.b)("inlineCode",{parentName:"p"},"render")," method takes our existing ",Object(i.b)("inlineCode",{parentName:"p"},"state")," and returns the ",Object(i.b)("inlineCode",{parentName:"p"},"Player")," Sprite:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'  render({ state }) {\n    return [\n      Player({\n        id: "player",\n        x: state.playerX,\n        rotation: 10,\n        color: "red",\n      }),\n    ];\n  },\n')),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Player")," (which we created above using ",Object(i.b)("inlineCode",{parentName:"p"},"makeSprite"),") is just a function we can call with its ",Object(i.b)("inlineCode",{parentName:"p"},"props"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"id"),": Every custom Sprite (not Textures) requires an ",Object(i.b)("inlineCode",{parentName:"li"},"id")," prop, which is a string of any value you want. The ",Object(i.b)("inlineCode",{parentName:"li"},"id")," ",Object(i.b)("strong",{parentName:"li"},"must be unique within a single render function"),", but doesn't need to be unique globally. The unique ",Object(i.b)("inlineCode",{parentName:"li"},"id")," is how Replay tracks the ",Object(i.b)("inlineCode",{parentName:"li"},"state")," of different Sprites."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"x"),": Every Sprite (including Textures) has an optional ",Object(i.b)("inlineCode",{parentName:"li"},"x")," and ",Object(i.b)("inlineCode",{parentName:"li"},"y")," prop to set its position."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"rotation"),": Like the ",Object(i.b)("inlineCode",{parentName:"li"},"x")," prop, you can set the Sprite's rotation in degrees."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"color"),": This is the prop defined in the ",Object(i.b)("inlineCode",{parentName:"li"},"Player")," Sprite itself.")),Object(i.b)("h2",{id:"anchor-point"},"Anchor Point"),Object(i.b)("p",null,"When Sprites are positioned, the position is relative the ",Object(i.b)("em",{parentName:"p"},"anchor point"),", which is in the middle of the Sprite. You can then adjust this anchor point using the ",Object(i.b)("inlineCode",{parentName:"p"},"anchorX")," and ",Object(i.b)("inlineCode",{parentName:"p"},"anchorY")," props (see ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"#common-props"}),"Common Props")," below). ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/game-size"}),"Game Size")," covers the coordinate system in more detail."),Object(i.b)("img",{src:"/img/anchor-point.png",width:"50%"}),Object(i.b)("h2",{id:"common-props"},"Common Props"),Object(i.b)("p",null,"All Sprites can be given the following props:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"id"),": (Required) Identifier, must be unique within a single render function."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"x"),": x coordinate of Sprite. Default ",Object(i.b)("inlineCode",{parentName:"li"},"0"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"y"),": y coordinate of Sprite. Default ",Object(i.b)("inlineCode",{parentName:"li"},"0"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"rotation"),": Rotation of Sprite around anchor point in degrees (clockwise). Default ",Object(i.b)("inlineCode",{parentName:"li"},"0"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"opacity"),": A number between 0 and 1. Default ",Object(i.b)("inlineCode",{parentName:"li"},"1"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"scaleX"),": Scale the Texture horizontally around the anchor point. Default ",Object(i.b)("inlineCode",{parentName:"li"},"1"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"scaleY"),": Scale the Texture vertically around the anchor point. Default ",Object(i.b)("inlineCode",{parentName:"li"},"1"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"anchorX"),": Move the ",Object(i.b)("inlineCode",{parentName:"li"},"x")," anchor point in game coordinates from the center point of the Sprite. Default ",Object(i.b)("inlineCode",{parentName:"li"},"0"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"anchorY"),": Move the ",Object(i.b)("inlineCode",{parentName:"li"},"y")," anchor point in game coordinates from the center point of the Sprite. Default ",Object(i.b)("inlineCode",{parentName:"li"},"0"),".")),Object(i.b)("p",null,"Here's how you could combine ",Object(i.b)("inlineCode",{parentName:"p"},"anchorX")," and ",Object(i.b)("inlineCode",{parentName:"p"},"scaleX")," for a health bar effect:"),Object(i.b)("p",null,Object(i.b)("img",Object(r.a)({parentName:"p"},{src:"/img/anchor-scale.png",alt:"anchorX and scaleX usage for health bar"}))),Object(i.b)("h2",{id:"sprite-methods"},"Sprite Methods"),Object(i.b)("p",null,"Sprite methods are the fields of the object you pass into ",Object(i.b)("inlineCode",{parentName:"p"},"makeSprite"),". ",Object(i.b)("inlineCode",{parentName:"p"},"render")," is the only ",Object(i.b)("em",{parentName:"p"},"required")," Sprite method. ",Object(i.b)("inlineCode",{parentName:"p"},"init")," is required if your Sprite has ",Object(i.b)("inlineCode",{parentName:"p"},"state"),"."),Object(i.b)("h3",{id:"common-parameters"},"Common Parameters"),Object(i.b)("p",null,"All Sprite methods have the following parameters:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"props"),": The props passed in by the parent Sprite."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"device"),": The device object, see ",Object(i.b)("a",Object(r.a)({parentName:"li"},{href:"/docs/device"}),"Device"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"updateState"),": A callback to update the ",Object(i.b)("inlineCode",{parentName:"li"},"state")," of the Sprite. Useful for asynchronous things like timers. Pass a function which takes the existing state and returns a new state. E.g:",Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"updateState((prevState) => ({ ...prevState, playerX: 0 }));\n")))),Object(i.b)("h3",{id:"init"},Object(i.b)("inlineCode",{parentName:"h3"},"init")),Object(i.b)("p",null,"Called on initial load of Sprite. Use this to run anything you need on setup. Returns the initial state."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"  init({ props, device, updateState }) {\n    return { ... };\n  },\n")),Object(i.b)("h3",{id:"loop"},Object(i.b)("inlineCode",{parentName:"h3"},"loop")),Object(i.b)("p",null,"Called every frame of the game. Put your game logic here. Returns the next frame's state."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"  loop({ props, state, device, updateState }) {\n    return { ...state, ... };\n  },\n")),Object(i.b)("h4",{id:"additional-parameters"},"Additional Parameters"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"state"),": The current state of the Sprite.")),Object(i.b)("h3",{id:"render"},Object(i.b)("inlineCode",{parentName:"h3"},"render")),Object(i.b)("p",null,"Called when the device renders to screen. Returns an array of Sprites to render."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"  render({ props, state, device, updateState, extrapolateFactor }) {\n    return [ ... ];\n  },\n")),Object(i.b)("h4",{id:"additional-parameters-1"},"Additional Parameters"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"state"),": The current state of the Sprite."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"extrapolateFactor"),": A value between 0 and 1 representing how much time has passed before the next frame is scheduled. See ",Object(i.b)("a",Object(r.a)({parentName:"li"},{href:"/docs/game-loop"}),"Game Loop")," for more.")),Object(i.b)("h3",{id:"renderp"},Object(i.b)("inlineCode",{parentName:"h3"},"renderP")),Object(i.b)("p",null,"An alternative render method run if the device is in portrait. See ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/game-size"}),"Game Size")," for more."),Object(i.b)("h3",{id:"renderxl"},Object(i.b)("inlineCode",{parentName:"h3"},"renderXL")),Object(i.b)("p",null,"An alternative render method run for large screens. See ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/game-size"}),"Game Size")," for more."),Object(i.b)("h3",{id:"renderpxl"},Object(i.b)("inlineCode",{parentName:"h3"},"renderPXL")),Object(i.b)("p",null,"An alternative render method run for large screens if the device is in portrait. See ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/game-size"}),"Game Size")," for more."))}u.isMDXComponent=!0},220:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return m}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),b=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},s=function(e){var t=b(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=Object(r.forwardRef)((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),s=b(n),d=r,m=s["".concat(o,".").concat(d)]||s[d]||u[d]||i;return n?a.a.createElement(m,l({ref:t},c,{components:n})):a.a.createElement(m,l({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},225:function(e,t,n){var r;!function(){"use strict";var n={}.hasOwnProperty;function a(){for(var e=[],t=0;t<arguments.length;t++){var r=arguments[t];if(r){var i=typeof r;if("string"===i||"number"===i)e.push(r);else if(Array.isArray(r)&&r.length){var o=a.apply(null,r);o&&e.push(o)}else if("object"===i)for(var l in r)n.call(r,l)&&r[l]&&e.push(l)}}return e.join(" ")}e.exports?(a.default=a,e.exports=a):void 0===(r=function(){return a}.apply(t,[]))||(e.exports=r)}()},228:function(e,t,n){"use strict";var r=n(0),a=n.n(r);t.a=function(e){return a.a.createElement("div",null,e.children)}},229:function(e,t,n){"use strict";n(25),n(20),n(21);var r=n(0),a=n.n(r),i=n(245);var o=function(){return Object(r.useContext)(i.a)},l=n(225),p=n.n(l),c=n(133),b=n.n(c),s=37,u=39;t.a=function(e){var t=e.block,n=e.children,i=e.defaultValue,l=e.values,c=e.groupId,d=o(),m=d.tabGroupChoices,j=d.setTabGroupChoices,O=Object(r.useState)(i),h=O[0],f=O[1];if(null!=c){var N=m[c];null!=N&&N!==h&&f(N)}var y=function(e){f(e),null!=c&&j(c,e)},v=[];return a.a.createElement("div",null,a.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:p()("tabs",{"tabs--block":t})},l.map((function(e){var t=e.value,n=e.label;return a.a.createElement("li",{role:"tab",tabIndex:"0","aria-selected":h===t,className:p()("tab-item",b.a.tabItem,{"tab-item--active":h===t}),key:t,ref:function(e){return v.push(e)},onKeyDown:function(e){return function(e,t,n){switch(n.keyCode){case u:!function(e,t){var n=e.indexOf(t)+1;e[n]?e[n].focus():e[0].focus()}(e,t);break;case s:!function(e,t){var n=e.indexOf(t)-1;e[n]?e[n].focus():e[e.length-1].focus()}(e,t)}}(v,e.target,e)},onFocus:function(){return y(t)},onClick:function(){return y(t)}},n)}))),a.a.createElement("div",{role:"tabpanel",className:"margin-vert--md"},r.Children.toArray(n).filter((function(e){return e.props.value===h}))[0]))}},245:function(e,t,n){"use strict";var r=n(0),a=Object(r.createContext)({tabGroupChoices:{},setTabGroupChoices:function(){}});t.a=a}}]);